// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// zstd ffi binding in Dart
class ZStd {
  /// Holds the Dynamic library.
  final ffi.DynamicLibrary _dylib;

  /// The symbols are looked up in [dynamicLibrary].
  ZStd(ffi.DynamicLibrary dynamicLibrary) : _dylib = dynamicLibrary;

  /// ! ZSTD_versionNumber() :
  /// Return runtime library version, the value is (MAJOR*100*100 + MINOR*100 + RELEASE).
  int ZSTD_versionNumber() {
    _ZSTD_versionNumber ??=
        _dylib.lookupFunction<_c_ZSTD_versionNumber, _dart_ZSTD_versionNumber>(
            'ZSTD_versionNumber');
    return _ZSTD_versionNumber();
  }

  _dart_ZSTD_versionNumber _ZSTD_versionNumber;

  /// ! ZSTD_versionString() :
  /// Return runtime library version, like "1.4.5". Requires v1.3.0+.
  ffi.Pointer<ffi.Int8> ZSTD_versionString() {
    _ZSTD_versionString ??=
        _dylib.lookupFunction<_c_ZSTD_versionString, _dart_ZSTD_versionString>(
            'ZSTD_versionString');
    return _ZSTD_versionString();
  }

  _dart_ZSTD_versionString _ZSTD_versionString;

  /// Simple API
  ///
  /// ! ZSTD_compress() :
  /// Compresses `src` content as a single zstd compressed frame into already allocated `dst`.
  /// Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`.
  /// @return : compressed size written into `dst` (<= `dstCapacity),
  /// or an error code if it fails (which can be tested using ZSTD_isError()).
  int ZSTD_compress(
    ffi.Pointer<ffi.Void> dst,
    int dstCapacity,
    ffi.Pointer<ffi.Void> src,
    int srcSize,
    int compressionLevel,
  ) {
    _ZSTD_compress ??= _dylib
        .lookupFunction<_c_ZSTD_compress, _dart_ZSTD_compress>('ZSTD_compress');
    return _ZSTD_compress(
      dst,
      dstCapacity,
      src,
      srcSize,
      compressionLevel,
    );
  }

  _dart_ZSTD_compress _ZSTD_compress;

  /// ! ZSTD_decompress() :
  /// `compressedSize` : must be the _exact_ size of some number of compressed and/or skippable frames.
  /// `dstCapacity` is an upper bound of originalSize to regenerate.
  /// If user cannot imply a maximum upper bound, it's better to use streaming mode to decompress data.
  /// @return : the number of bytes decompressed into `dst` (<= `dstCapacity`),
  /// or an errorCode if it fails (which can be tested using ZSTD_isError()).
  int ZSTD_decompress(
    ffi.Pointer<ffi.Void> dst,
    int dstCapacity,
    ffi.Pointer<ffi.Void> src,
    int compressedSize,
  ) {
    _ZSTD_decompress ??=
        _dylib.lookupFunction<_c_ZSTD_decompress, _dart_ZSTD_decompress>(
            'ZSTD_decompress');
    return _ZSTD_decompress(
      dst,
      dstCapacity,
      src,
      compressedSize,
    );
  }

  _dart_ZSTD_decompress _ZSTD_decompress;

  int ZSTD_getFrameContentSize(
    ffi.Pointer<ffi.Void> src,
    int srcSize,
  ) {
    _ZSTD_getFrameContentSize ??= _dylib.lookupFunction<
        _c_ZSTD_getFrameContentSize,
        _dart_ZSTD_getFrameContentSize>('ZSTD_getFrameContentSize');
    return _ZSTD_getFrameContentSize(
      src,
      srcSize,
    );
  }

  _dart_ZSTD_getFrameContentSize _ZSTD_getFrameContentSize;

  /// ! ZSTD_getDecompressedSize() :
  /// NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize().
  /// Both functions work the same way, but ZSTD_getDecompressedSize() blends
  /// "empty", "unknown" and "error" results to the same return value (0),
  /// while ZSTD_getFrameContentSize() gives them separate return values.
  /// @return : decompressed size of `src` frame content _if known and not empty_, 0 otherwise.
  int ZSTD_getDecompressedSize(
    ffi.Pointer<ffi.Void> src,
    int srcSize,
  ) {
    _ZSTD_getDecompressedSize ??= _dylib.lookupFunction<
        _c_ZSTD_getDecompressedSize,
        _dart_ZSTD_getDecompressedSize>('ZSTD_getDecompressedSize');
    return _ZSTD_getDecompressedSize(
      src,
      srcSize,
    );
  }

  _dart_ZSTD_getDecompressedSize _ZSTD_getDecompressedSize;

  /// ! ZSTD_findFrameCompressedSize() :
  /// `src` should point to the start of a ZSTD frame or skippable frame.
  /// `srcSize` must be >= first frame size
  /// @return : the compressed size of the first frame starting at `src`,
  /// suitable to pass as `srcSize` to `ZSTD_decompress` or similar,
  /// or an error code if input is invalid
  int ZSTD_findFrameCompressedSize(
    ffi.Pointer<ffi.Void> src,
    int srcSize,
  ) {
    _ZSTD_findFrameCompressedSize ??= _dylib.lookupFunction<
        _c_ZSTD_findFrameCompressedSize,
        _dart_ZSTD_findFrameCompressedSize>('ZSTD_findFrameCompressedSize');
    return _ZSTD_findFrameCompressedSize(
      src,
      srcSize,
    );
  }

  _dart_ZSTD_findFrameCompressedSize _ZSTD_findFrameCompressedSize;

  int ZSTD_compressBound(
    int srcSize,
  ) {
    _ZSTD_compressBound ??=
        _dylib.lookupFunction<_c_ZSTD_compressBound, _dart_ZSTD_compressBound>(
            'ZSTD_compressBound');
    return _ZSTD_compressBound(
      srcSize,
    );
  }

  _dart_ZSTD_compressBound _ZSTD_compressBound;

  int ZSTD_isError(
    int code,
  ) {
    _ZSTD_isError ??= _dylib
        .lookupFunction<_c_ZSTD_isError, _dart_ZSTD_isError>('ZSTD_isError');
    return _ZSTD_isError(
      code,
    );
  }

  _dart_ZSTD_isError _ZSTD_isError;

  ffi.Pointer<ffi.Int8> ZSTD_getErrorName(
    int code,
  ) {
    _ZSTD_getErrorName ??=
        _dylib.lookupFunction<_c_ZSTD_getErrorName, _dart_ZSTD_getErrorName>(
            'ZSTD_getErrorName');
    return _ZSTD_getErrorName(
      code,
    );
  }

  _dart_ZSTD_getErrorName _ZSTD_getErrorName;

  int ZSTD_minCLevel() {
    _ZSTD_minCLevel ??=
        _dylib.lookupFunction<_c_ZSTD_minCLevel, _dart_ZSTD_minCLevel>(
            'ZSTD_minCLevel');
    return _ZSTD_minCLevel();
  }

  _dart_ZSTD_minCLevel _ZSTD_minCLevel;

  int ZSTD_maxCLevel() {
    _ZSTD_maxCLevel ??=
        _dylib.lookupFunction<_c_ZSTD_maxCLevel, _dart_ZSTD_maxCLevel>(
            'ZSTD_maxCLevel');
    return _ZSTD_maxCLevel();
  }

  _dart_ZSTD_maxCLevel _ZSTD_maxCLevel;

  ffi.Pointer<ZSTD_CCtx_s> ZSTD_createCCtx() {
    _ZSTD_createCCtx ??=
        _dylib.lookupFunction<_c_ZSTD_createCCtx, _dart_ZSTD_createCCtx>(
            'ZSTD_createCCtx');
    return _ZSTD_createCCtx();
  }

  _dart_ZSTD_createCCtx _ZSTD_createCCtx;

  int ZSTD_freeCCtx(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
  ) {
    _ZSTD_freeCCtx ??= _dylib
        .lookupFunction<_c_ZSTD_freeCCtx, _dart_ZSTD_freeCCtx>('ZSTD_freeCCtx');
    return _ZSTD_freeCCtx(
      cctx,
    );
  }

  _dart_ZSTD_freeCCtx _ZSTD_freeCCtx;

  /// ! ZSTD_compressCCtx() :
  /// Same as ZSTD_compress(), using an explicit ZSTD_CCtx.
  /// Important : in order to behave similarly to `ZSTD_compress()`,
  /// this function compresses at requested compression level,
  /// __ignoring any other parameter__ .
  /// If any advanced parameter was set using the advanced API,
  /// they will all be reset. Only `compressionLevel` remains.
  int ZSTD_compressCCtx(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
    ffi.Pointer<ffi.Void> dst,
    int dstCapacity,
    ffi.Pointer<ffi.Void> src,
    int srcSize,
    int compressionLevel,
  ) {
    _ZSTD_compressCCtx ??=
        _dylib.lookupFunction<_c_ZSTD_compressCCtx, _dart_ZSTD_compressCCtx>(
            'ZSTD_compressCCtx');
    return _ZSTD_compressCCtx(
      cctx,
      dst,
      dstCapacity,
      src,
      srcSize,
      compressionLevel,
    );
  }

  _dart_ZSTD_compressCCtx _ZSTD_compressCCtx;

  ffi.Pointer<ZSTD_DCtx_s> ZSTD_createDCtx() {
    _ZSTD_createDCtx ??=
        _dylib.lookupFunction<_c_ZSTD_createDCtx, _dart_ZSTD_createDCtx>(
            'ZSTD_createDCtx');
    return _ZSTD_createDCtx();
  }

  _dart_ZSTD_createDCtx _ZSTD_createDCtx;

  int ZSTD_freeDCtx(
    ffi.Pointer<ZSTD_DCtx_s> dctx,
  ) {
    _ZSTD_freeDCtx ??= _dylib
        .lookupFunction<_c_ZSTD_freeDCtx, _dart_ZSTD_freeDCtx>('ZSTD_freeDCtx');
    return _ZSTD_freeDCtx(
      dctx,
    );
  }

  _dart_ZSTD_freeDCtx _ZSTD_freeDCtx;

  /// ! ZSTD_decompressDCtx() :
  /// Same as ZSTD_decompress(),
  /// requires an allocated ZSTD_DCtx.
  /// Compatible with sticky parameters.
  int ZSTD_decompressDCtx(
    ffi.Pointer<ZSTD_DCtx_s> dctx,
    ffi.Pointer<ffi.Void> dst,
    int dstCapacity,
    ffi.Pointer<ffi.Void> src,
    int srcSize,
  ) {
    _ZSTD_decompressDCtx ??= _dylib.lookupFunction<_c_ZSTD_decompressDCtx,
        _dart_ZSTD_decompressDCtx>('ZSTD_decompressDCtx');
    return _ZSTD_decompressDCtx(
      dctx,
      dst,
      dstCapacity,
      src,
      srcSize,
    );
  }

  _dart_ZSTD_decompressDCtx _ZSTD_decompressDCtx;

  /// ! ZSTD_CCtx_setParameter() :
  /// Set one compression parameter, selected by enum ZSTD_cParameter.
  /// All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds().
  /// Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
  /// Setting a parameter is generally only possible during frame initialization (before starting compression).
  /// Exception : when using multi-threading mode (nbWorkers >= 1),
  /// the following parameters can be updated _during_ compression (within same frame):
  /// => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy.
  /// new parameters will be active for next job only (after a flush()).
  /// @return : an error code (which can be tested using ZSTD_isError()).
  int ZSTD_CCtx_setParameter(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
    int param,
    int value,
  ) {
    _ZSTD_CCtx_setParameter ??= _dylib.lookupFunction<_c_ZSTD_CCtx_setParameter,
        _dart_ZSTD_CCtx_setParameter>('ZSTD_CCtx_setParameter');
    return _ZSTD_CCtx_setParameter(
      cctx,
      param,
      value,
    );
  }

  _dart_ZSTD_CCtx_setParameter _ZSTD_CCtx_setParameter;

  /// ! ZSTD_CCtx_setPledgedSrcSize() :
  /// Total input data size to be compressed as a single frame.
  /// Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag.
  /// This value will also be controlled at end of frame, and trigger an error if not respected.
  /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
  /// Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame.
  /// In order to mean "unknown content size", pass constant ZSTD_CONTENTSIZE_UNKNOWN.
  /// ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame.
  /// Note 2 : pledgedSrcSize is only valid once, for the next frame.
  /// It's discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN.
  /// Note 3 : Whenever all input data is provided and consumed in a single round,
  /// for example with ZSTD_compress2(),
  /// or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end),
  /// this value is automatically overridden by srcSize instead.
  int ZSTD_CCtx_setPledgedSrcSize(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
    int pledgedSrcSize,
  ) {
    _ZSTD_CCtx_setPledgedSrcSize ??= _dylib.lookupFunction<
        _c_ZSTD_CCtx_setPledgedSrcSize,
        _dart_ZSTD_CCtx_setPledgedSrcSize>('ZSTD_CCtx_setPledgedSrcSize');
    return _ZSTD_CCtx_setPledgedSrcSize(
      cctx,
      pledgedSrcSize,
    );
  }

  _dart_ZSTD_CCtx_setPledgedSrcSize _ZSTD_CCtx_setPledgedSrcSize;

  /// ! ZSTD_CCtx_reset() :
  /// There are 2 different things that can be reset, independently or jointly :
  /// - The session : will stop compressing current frame, and make CCtx ready to start a new one.
  /// Useful after an error, or to interrupt any ongoing compression.
  /// Any internal data not yet flushed is cancelled.
  /// Compression parameters and dictionary remain unchanged.
  /// They will be used to compress next frame.
  /// Resetting session never fails.
  /// - The parameters : changes all parameters back to "default".
  /// This removes any reference to any dictionary too.
  /// Parameters can only be changed between 2 sessions (i.e. no compression is currently ongoing)
  /// otherwise the reset fails, and function returns an error value (which can be tested using ZSTD_isError())
  /// - Both : similar to resetting the session, followed by resetting parameters.
  int ZSTD_CCtx_reset(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
    int reset,
  ) {
    _ZSTD_CCtx_reset ??=
        _dylib.lookupFunction<_c_ZSTD_CCtx_reset, _dart_ZSTD_CCtx_reset>(
            'ZSTD_CCtx_reset');
    return _ZSTD_CCtx_reset(
      cctx,
      reset,
    );
  }

  _dart_ZSTD_CCtx_reset _ZSTD_CCtx_reset;

  /// ! ZSTD_compress2() :
  /// Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API.
  /// ZSTD_compress2() always starts a new frame.
  /// Should cctx hold data from a previously unfinished frame, everything about it is forgotten.
  /// - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()
  /// - The function is always blocking, returns when compression is completed.
  /// Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`.
  /// @return : compressed size written into `dst` (<= `dstCapacity),
  /// or an error code if it fails (which can be tested using ZSTD_isError()).
  int ZSTD_compress2(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
    ffi.Pointer<ffi.Void> dst,
    int dstCapacity,
    ffi.Pointer<ffi.Void> src,
    int srcSize,
  ) {
    _ZSTD_compress2 ??=
        _dylib.lookupFunction<_c_ZSTD_compress2, _dart_ZSTD_compress2>(
            'ZSTD_compress2');
    return _ZSTD_compress2(
      cctx,
      dst,
      dstCapacity,
      src,
      srcSize,
    );
  }

  _dart_ZSTD_compress2 _ZSTD_compress2;

  /// ! ZSTD_DCtx_setParameter() :
  /// Set one compression parameter, selected by enum ZSTD_dParameter.
  /// All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds().
  /// Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter).
  /// Setting a parameter is only possible during frame initialization (before starting decompression).
  /// @return : 0, or an error code (which can be tested using ZSTD_isError()).
  int ZSTD_DCtx_setParameter(
    ffi.Pointer<ZSTD_DCtx_s> dctx,
    int param,
    int value,
  ) {
    _ZSTD_DCtx_setParameter ??= _dylib.lookupFunction<_c_ZSTD_DCtx_setParameter,
        _dart_ZSTD_DCtx_setParameter>('ZSTD_DCtx_setParameter');
    return _ZSTD_DCtx_setParameter(
      dctx,
      param,
      value,
    );
  }

  _dart_ZSTD_DCtx_setParameter _ZSTD_DCtx_setParameter;

  /// ! ZSTD_DCtx_reset() :
  /// Return a DCtx to clean state.
  /// Session and parameters can be reset jointly or separately.
  /// Parameters can only be reset when no active frame is being decompressed.
  /// @return : 0, or an error code, which can be tested with ZSTD_isError()
  int ZSTD_DCtx_reset(
    ffi.Pointer<ZSTD_DCtx_s> dctx,
    int reset,
  ) {
    _ZSTD_DCtx_reset ??=
        _dylib.lookupFunction<_c_ZSTD_DCtx_reset, _dart_ZSTD_DCtx_reset>(
            'ZSTD_DCtx_reset');
    return _ZSTD_DCtx_reset(
      dctx,
      reset,
    );
  }

  _dart_ZSTD_DCtx_reset _ZSTD_DCtx_reset;

  ffi.Pointer<ZSTD_CCtx_s> ZSTD_createCStream() {
    _ZSTD_createCStream ??=
        _dylib.lookupFunction<_c_ZSTD_createCStream, _dart_ZSTD_createCStream>(
            'ZSTD_createCStream');
    return _ZSTD_createCStream();
  }

  _dart_ZSTD_createCStream _ZSTD_createCStream;

  int ZSTD_freeCStream(
    ffi.Pointer<ZSTD_CCtx_s> zcs,
  ) {
    _ZSTD_freeCStream ??=
        _dylib.lookupFunction<_c_ZSTD_freeCStream, _dart_ZSTD_freeCStream>(
            'ZSTD_freeCStream');
    return _ZSTD_freeCStream(
      zcs,
    );
  }

  _dart_ZSTD_freeCStream _ZSTD_freeCStream;

  /// ! ZSTD_compressStream2() :
  /// Behaves about the same as ZSTD_compressStream, with additional control on end directive.
  /// - Compression parameters are pushed into CCtx before starting compression, using ZSTD_CCtx_set*()
  /// - Compression parameters cannot be changed once compression is started (save a list of exceptions in multi-threading mode)
  /// - output->pos must be <= dstCapacity, input->pos must be <= srcSize
  /// - output->pos and input->pos will be updated. They are guaranteed to remain below their respective limit.
  /// - endOp must be a valid directive
  /// - When nbWorkers==0 (default), function is blocking : it completes its job before returning to caller.
  /// - When nbWorkers>=1, function is non-blocking : it copies a portion of input, distributes jobs to internal worker threads, flush to output whatever is available,
  /// and then immediately returns, just indicating that there is some data remaining to be flushed.
  /// The function nonetheless guarantees forward progress : it will return only after it reads or write at least 1+ byte.
  /// - Exception : if the first call requests a ZSTD_e_end directive and provides enough dstCapacity, the function delegates to ZSTD_compress2() which is always blocking.
  /// - @return provides a minimum amount of data remaining to be flushed from internal buffers
  /// or an error code, which can be tested using ZSTD_isError().
  /// if @return != 0, flush is not fully completed, there is still some data left within internal buffers.
  /// This is useful for ZSTD_e_flush, since in this case more flushes are necessary to empty all buffers.
  /// For ZSTD_e_end, @return == 0 when internal buffers are fully flushed and frame is completed.
  /// - after a ZSTD_e_end directive, if internal buffer is not fully flushed (@return != 0),
  /// only ZSTD_e_end or ZSTD_e_flush operations are allowed.
  /// Before starting a new compression job, or changing compression parameters,
  /// it is required to fully flush internal buffers.
  int ZSTD_compressStream2(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
    ffi.Pointer<ZSTD_outBuffer> output,
    ffi.Pointer<ZSTD_inBuffer> input,
    int endOp,
  ) {
    _ZSTD_compressStream2 ??= _dylib.lookupFunction<_c_ZSTD_compressStream2,
        _dart_ZSTD_compressStream2>('ZSTD_compressStream2');
    return _ZSTD_compressStream2(
      cctx,
      output,
      input,
      endOp,
    );
  }

  _dart_ZSTD_compressStream2 _ZSTD_compressStream2;

  int ZSTD_CStreamInSize() {
    _ZSTD_CStreamInSize ??=
        _dylib.lookupFunction<_c_ZSTD_CStreamInSize, _dart_ZSTD_CStreamInSize>(
            'ZSTD_CStreamInSize');
    return _ZSTD_CStreamInSize();
  }

  _dart_ZSTD_CStreamInSize _ZSTD_CStreamInSize;

  int ZSTD_CStreamOutSize() {
    _ZSTD_CStreamOutSize ??= _dylib.lookupFunction<_c_ZSTD_CStreamOutSize,
        _dart_ZSTD_CStreamOutSize>('ZSTD_CStreamOutSize');
    return _ZSTD_CStreamOutSize();
  }

  _dart_ZSTD_CStreamOutSize _ZSTD_CStreamOutSize;

  /// !
  /// Equivalent to:
  ///
  /// ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only);
  /// ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any)
  /// ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel);
  int ZSTD_initCStream(
    ffi.Pointer<ZSTD_CCtx_s> zcs,
    int compressionLevel,
  ) {
    _ZSTD_initCStream ??=
        _dylib.lookupFunction<_c_ZSTD_initCStream, _dart_ZSTD_initCStream>(
            'ZSTD_initCStream');
    return _ZSTD_initCStream(
      zcs,
      compressionLevel,
    );
  }

  _dart_ZSTD_initCStream _ZSTD_initCStream;

  /// !
  /// Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue).
  /// NOTE: The return value is different. ZSTD_compressStream() returns a hint for
  /// the next read size (if non-zero and not an error). ZSTD_compressStream2()
  /// returns the minimum nb of bytes left to flush (if non-zero and not an error).
  int ZSTD_compressStream(
    ffi.Pointer<ZSTD_CCtx_s> zcs,
    ffi.Pointer<ZSTD_outBuffer> output,
    ffi.Pointer<ZSTD_inBuffer> input,
  ) {
    _ZSTD_compressStream ??= _dylib.lookupFunction<_c_ZSTD_compressStream,
        _dart_ZSTD_compressStream>('ZSTD_compressStream');
    return _ZSTD_compressStream(
      zcs,
      output,
      input,
    );
  }

  _dart_ZSTD_compressStream _ZSTD_compressStream;

  /// ! Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush).
  int ZSTD_flushStream(
    ffi.Pointer<ZSTD_CCtx_s> zcs,
    ffi.Pointer<ZSTD_outBuffer> output,
  ) {
    _ZSTD_flushStream ??=
        _dylib.lookupFunction<_c_ZSTD_flushStream, _dart_ZSTD_flushStream>(
            'ZSTD_flushStream');
    return _ZSTD_flushStream(
      zcs,
      output,
    );
  }

  _dart_ZSTD_flushStream _ZSTD_flushStream;

  /// ! Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end).
  int ZSTD_endStream(
    ffi.Pointer<ZSTD_CCtx_s> zcs,
    ffi.Pointer<ZSTD_outBuffer> output,
  ) {
    _ZSTD_endStream ??=
        _dylib.lookupFunction<_c_ZSTD_endStream, _dart_ZSTD_endStream>(
            'ZSTD_endStream');
    return _ZSTD_endStream(
      zcs,
      output,
    );
  }

  _dart_ZSTD_endStream _ZSTD_endStream;

  ffi.Pointer<ZSTD_DCtx_s> ZSTD_createDStream() {
    _ZSTD_createDStream ??=
        _dylib.lookupFunction<_c_ZSTD_createDStream, _dart_ZSTD_createDStream>(
            'ZSTD_createDStream');
    return _ZSTD_createDStream();
  }

  _dart_ZSTD_createDStream _ZSTD_createDStream;

  int ZSTD_freeDStream(
    ffi.Pointer<ZSTD_DCtx_s> zds,
  ) {
    _ZSTD_freeDStream ??=
        _dylib.lookupFunction<_c_ZSTD_freeDStream, _dart_ZSTD_freeDStream>(
            'ZSTD_freeDStream');
    return _ZSTD_freeDStream(
      zds,
    );
  }

  _dart_ZSTD_freeDStream _ZSTD_freeDStream;

  int ZSTD_initDStream(
    ffi.Pointer<ZSTD_DCtx_s> zds,
  ) {
    _ZSTD_initDStream ??=
        _dylib.lookupFunction<_c_ZSTD_initDStream, _dart_ZSTD_initDStream>(
            'ZSTD_initDStream');
    return _ZSTD_initDStream(
      zds,
    );
  }

  _dart_ZSTD_initDStream _ZSTD_initDStream;

  int ZSTD_decompressStream(
    ffi.Pointer<ZSTD_DCtx_s> zds,
    ffi.Pointer<ZSTD_outBuffer> output,
    ffi.Pointer<ZSTD_inBuffer> input,
  ) {
    _ZSTD_decompressStream ??= _dylib.lookupFunction<_c_ZSTD_decompressStream,
        _dart_ZSTD_decompressStream>('ZSTD_decompressStream');
    return _ZSTD_decompressStream(
      zds,
      output,
      input,
    );
  }

  _dart_ZSTD_decompressStream _ZSTD_decompressStream;

  int ZSTD_DStreamInSize() {
    _ZSTD_DStreamInSize ??=
        _dylib.lookupFunction<_c_ZSTD_DStreamInSize, _dart_ZSTD_DStreamInSize>(
            'ZSTD_DStreamInSize');
    return _ZSTD_DStreamInSize();
  }

  _dart_ZSTD_DStreamInSize _ZSTD_DStreamInSize;

  int ZSTD_DStreamOutSize() {
    _ZSTD_DStreamOutSize ??= _dylib.lookupFunction<_c_ZSTD_DStreamOutSize,
        _dart_ZSTD_DStreamOutSize>('ZSTD_DStreamOutSize');
    return _ZSTD_DStreamOutSize();
  }

  _dart_ZSTD_DStreamOutSize _ZSTD_DStreamOutSize;

  /// Simple dictionary API
  ///
  /// ! ZSTD_compress_usingDict() :
  /// Compression at an explicit compression level using a Dictionary.
  /// A dictionary can be any arbitrary data segment (also called a prefix),
  /// or a buffer with specified information (see dictBuilder/zdict.h).
  /// Note : This function loads the dictionary, resulting in significant startup delay.
  /// It's intended for a dictionary used only once.
  /// Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used.
  int ZSTD_compress_usingDict(
    ffi.Pointer<ZSTD_CCtx_s> ctx,
    ffi.Pointer<ffi.Void> dst,
    int dstCapacity,
    ffi.Pointer<ffi.Void> src,
    int srcSize,
    ffi.Pointer<ffi.Void> dict,
    int dictSize,
    int compressionLevel,
  ) {
    _ZSTD_compress_usingDict ??= _dylib.lookupFunction<
        _c_ZSTD_compress_usingDict,
        _dart_ZSTD_compress_usingDict>('ZSTD_compress_usingDict');
    return _ZSTD_compress_usingDict(
      ctx,
      dst,
      dstCapacity,
      src,
      srcSize,
      dict,
      dictSize,
      compressionLevel,
    );
  }

  _dart_ZSTD_compress_usingDict _ZSTD_compress_usingDict;

  /// ! ZSTD_decompress_usingDict() :
  /// Decompression using a known Dictionary.
  /// Dictionary must be identical to the one used during compression.
  /// Note : This function loads the dictionary, resulting in significant startup delay.
  /// It's intended for a dictionary used only once.
  /// Note : When `dict == NULL || dictSize < 8` no dictionary is used.
  int ZSTD_decompress_usingDict(
    ffi.Pointer<ZSTD_DCtx_s> dctx,
    ffi.Pointer<ffi.Void> dst,
    int dstCapacity,
    ffi.Pointer<ffi.Void> src,
    int srcSize,
    ffi.Pointer<ffi.Void> dict,
    int dictSize,
  ) {
    _ZSTD_decompress_usingDict ??= _dylib.lookupFunction<
        _c_ZSTD_decompress_usingDict,
        _dart_ZSTD_decompress_usingDict>('ZSTD_decompress_usingDict');
    return _ZSTD_decompress_usingDict(
      dctx,
      dst,
      dstCapacity,
      src,
      srcSize,
      dict,
      dictSize,
    );
  }

  _dart_ZSTD_decompress_usingDict _ZSTD_decompress_usingDict;

  /// ! ZSTD_createCDict() :
  /// When compressing multiple messages or blocks using the same dictionary,
  /// it's recommended to digest the dictionary only once, since it's a costly operation.
  /// ZSTD_createCDict() will create a state from digesting a dictionary.
  /// The resulting state can be used for future compression operations with very limited startup cost.
  /// ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.
  /// @dictBuffer can be released after ZSTD_CDict creation, because its content is copied within CDict.
  /// Note 1 : Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate @dictBuffer content.
  /// Note 2 : A ZSTD_CDict can be created from an empty @dictBuffer,
  /// in which case the only thing that it transports is the @compressionLevel.
  /// This can be useful in a pipeline featuring ZSTD_compress_usingCDict() exclusively,
  /// expecting a ZSTD_CDict parameter with any data, including those without a known dictionary.
  ffi.Pointer<ZSTD_CDict_s> ZSTD_createCDict(
    ffi.Pointer<ffi.Void> dictBuffer,
    int dictSize,
    int compressionLevel,
  ) {
    _ZSTD_createCDict ??=
        _dylib.lookupFunction<_c_ZSTD_createCDict, _dart_ZSTD_createCDict>(
            'ZSTD_createCDict');
    return _ZSTD_createCDict(
      dictBuffer,
      dictSize,
      compressionLevel,
    );
  }

  _dart_ZSTD_createCDict _ZSTD_createCDict;

  /// ! ZSTD_freeCDict() :
  /// Function frees memory allocated by ZSTD_createCDict().
  int ZSTD_freeCDict(
    ffi.Pointer<ZSTD_CDict_s> CDict,
  ) {
    _ZSTD_freeCDict ??=
        _dylib.lookupFunction<_c_ZSTD_freeCDict, _dart_ZSTD_freeCDict>(
            'ZSTD_freeCDict');
    return _ZSTD_freeCDict(
      CDict,
    );
  }

  _dart_ZSTD_freeCDict _ZSTD_freeCDict;

  /// ! ZSTD_compress_usingCDict() :
  /// Compression using a digested Dictionary.
  /// Recommended when same dictionary is used multiple times.
  /// Note : compression level is _decided at dictionary creation time_,
  /// and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)
  int ZSTD_compress_usingCDict(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
    ffi.Pointer<ffi.Void> dst,
    int dstCapacity,
    ffi.Pointer<ffi.Void> src,
    int srcSize,
    ffi.Pointer<ZSTD_CDict_s> cdict,
  ) {
    _ZSTD_compress_usingCDict ??= _dylib.lookupFunction<
        _c_ZSTD_compress_usingCDict,
        _dart_ZSTD_compress_usingCDict>('ZSTD_compress_usingCDict');
    return _ZSTD_compress_usingCDict(
      cctx,
      dst,
      dstCapacity,
      src,
      srcSize,
      cdict,
    );
  }

  _dart_ZSTD_compress_usingCDict _ZSTD_compress_usingCDict;

  /// ! ZSTD_createDDict() :
  /// Create a digested dictionary, ready to start decompression operation without startup delay.
  /// dictBuffer can be released after DDict creation, as its content is copied inside DDict.
  ffi.Pointer<ZSTD_DDict_s> ZSTD_createDDict(
    ffi.Pointer<ffi.Void> dictBuffer,
    int dictSize,
  ) {
    _ZSTD_createDDict ??=
        _dylib.lookupFunction<_c_ZSTD_createDDict, _dart_ZSTD_createDDict>(
            'ZSTD_createDDict');
    return _ZSTD_createDDict(
      dictBuffer,
      dictSize,
    );
  }

  _dart_ZSTD_createDDict _ZSTD_createDDict;

  /// ! ZSTD_freeDDict() :
  /// Function frees memory allocated with ZSTD_createDDict()
  int ZSTD_freeDDict(
    ffi.Pointer<ZSTD_DDict_s> ddict,
  ) {
    _ZSTD_freeDDict ??=
        _dylib.lookupFunction<_c_ZSTD_freeDDict, _dart_ZSTD_freeDDict>(
            'ZSTD_freeDDict');
    return _ZSTD_freeDDict(
      ddict,
    );
  }

  _dart_ZSTD_freeDDict _ZSTD_freeDDict;

  /// ! ZSTD_decompress_usingDDict() :
  /// Decompression using a digested Dictionary.
  /// Recommended when same dictionary is used multiple times.
  int ZSTD_decompress_usingDDict(
    ffi.Pointer<ZSTD_DCtx_s> dctx,
    ffi.Pointer<ffi.Void> dst,
    int dstCapacity,
    ffi.Pointer<ffi.Void> src,
    int srcSize,
    ffi.Pointer<ZSTD_DDict_s> ddict,
  ) {
    _ZSTD_decompress_usingDDict ??= _dylib.lookupFunction<
        _c_ZSTD_decompress_usingDDict,
        _dart_ZSTD_decompress_usingDDict>('ZSTD_decompress_usingDDict');
    return _ZSTD_decompress_usingDDict(
      dctx,
      dst,
      dstCapacity,
      src,
      srcSize,
      ddict,
    );
  }

  _dart_ZSTD_decompress_usingDDict _ZSTD_decompress_usingDDict;

  /// ! ZSTD_getDictID_fromDict() :
  /// Provides the dictID stored within dictionary.
  /// if @return == 0, the dictionary is not conformant with Zstandard specification.
  /// It can still be loaded, but as a content-only dictionary.
  int ZSTD_getDictID_fromDict(
    ffi.Pointer<ffi.Void> dict,
    int dictSize,
  ) {
    _ZSTD_getDictID_fromDict ??= _dylib.lookupFunction<
        _c_ZSTD_getDictID_fromDict,
        _dart_ZSTD_getDictID_fromDict>('ZSTD_getDictID_fromDict');
    return _ZSTD_getDictID_fromDict(
      dict,
      dictSize,
    );
  }

  _dart_ZSTD_getDictID_fromDict _ZSTD_getDictID_fromDict;

  /// ! ZSTD_getDictID_fromDDict() :
  /// Provides the dictID of the dictionary loaded into `ddict`.
  /// If @return == 0, the dictionary is not conformant to Zstandard specification, or empty.
  /// Non-conformant dictionaries can still be loaded, but as content-only dictionaries.
  int ZSTD_getDictID_fromDDict(
    ffi.Pointer<ZSTD_DDict_s> ddict,
  ) {
    _ZSTD_getDictID_fromDDict ??= _dylib.lookupFunction<
        _c_ZSTD_getDictID_fromDDict,
        _dart_ZSTD_getDictID_fromDDict>('ZSTD_getDictID_fromDDict');
    return _ZSTD_getDictID_fromDDict(
      ddict,
    );
  }

  _dart_ZSTD_getDictID_fromDDict _ZSTD_getDictID_fromDDict;

  /// ! ZSTD_getDictID_fromFrame() :
  /// Provides the dictID required to decompressed the frame stored within `src`.
  /// If @return == 0, the dictID could not be decoded.
  /// This could for one of the following reasons :
  /// - The frame does not require a dictionary to be decoded (most common case).
  /// - The frame was built with dictID intentionally removed. Whatever dictionary is necessary is a hidden information.
  /// Note : this use case also happens when using a non-conformant dictionary.
  /// - `srcSize` is too small, and as a result, the frame header could not be decoded (only possible if `srcSize < ZSTD_FRAMEHEADERSIZE_MAX`).
  /// - This is not a Zstandard frame.
  /// When identifying the exact failure cause, it's possible to use ZSTD_getFrameHeader(), which will provide a more precise error code.
  int ZSTD_getDictID_fromFrame(
    ffi.Pointer<ffi.Void> src,
    int srcSize,
  ) {
    _ZSTD_getDictID_fromFrame ??= _dylib.lookupFunction<
        _c_ZSTD_getDictID_fromFrame,
        _dart_ZSTD_getDictID_fromFrame>('ZSTD_getDictID_fromFrame');
    return _ZSTD_getDictID_fromFrame(
      src,
      srcSize,
    );
  }

  _dart_ZSTD_getDictID_fromFrame _ZSTD_getDictID_fromFrame;

  /// ! ZSTD_CCtx_loadDictionary() :
  /// Create an internal CDict from `dict` buffer.
  /// Decompression will have to use same dictionary.
  /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
  /// Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary,
  /// meaning "return to no-dictionary mode".
  /// Note 1 : Dictionary is sticky, it will be used for all future compressed frames.
  /// To return to "no-dictionary" situation, load a NULL dictionary (or reset parameters).
  /// Note 2 : Loading a dictionary involves building tables.
  /// It's also a CPU consuming operation, with non-negligible impact on latency.
  /// Tables are dependent on compression parameters, and for this reason,
  /// compression parameters can no longer be changed after loading a dictionary.
  /// Note 3 :`dict` content will be copied internally.
  /// Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead.
  /// In such a case, dictionary buffer must outlive its users.
  /// Note 4 : Use ZSTD_CCtx_loadDictionary_advanced()
  /// to precisely select how dictionary content must be interpreted.
  int ZSTD_CCtx_loadDictionary(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
    ffi.Pointer<ffi.Void> dict,
    int dictSize,
  ) {
    _ZSTD_CCtx_loadDictionary ??= _dylib.lookupFunction<
        _c_ZSTD_CCtx_loadDictionary,
        _dart_ZSTD_CCtx_loadDictionary>('ZSTD_CCtx_loadDictionary');
    return _ZSTD_CCtx_loadDictionary(
      cctx,
      dict,
      dictSize,
    );
  }

  _dart_ZSTD_CCtx_loadDictionary _ZSTD_CCtx_loadDictionary;

  /// ! ZSTD_CCtx_refCDict() :
  /// Reference a prepared dictionary, to be used for all next compressed frames.
  /// Note that compression parameters are enforced from within CDict,
  /// and supersede any compression parameter previously set within CCtx.
  /// The parameters ignored are labled as "superseded-by-cdict" in the ZSTD_cParameter enum docs.
  /// The ignored parameters will be used again if the CCtx is returned to no-dictionary mode.
  /// The dictionary will remain valid for future compressed frames using same CCtx.
  /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
  /// Special : Referencing a NULL CDict means "return to no-dictionary mode".
  /// Note 1 : Currently, only one dictionary can be managed.
  /// Referencing a new dictionary effectively "discards" any previous one.
  /// Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx.
  int ZSTD_CCtx_refCDict(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
    ffi.Pointer<ZSTD_CDict_s> cdict,
  ) {
    _ZSTD_CCtx_refCDict ??=
        _dylib.lookupFunction<_c_ZSTD_CCtx_refCDict, _dart_ZSTD_CCtx_refCDict>(
            'ZSTD_CCtx_refCDict');
    return _ZSTD_CCtx_refCDict(
      cctx,
      cdict,
    );
  }

  _dart_ZSTD_CCtx_refCDict _ZSTD_CCtx_refCDict;

  /// ! ZSTD_CCtx_refPrefix() :
  /// Reference a prefix (single-usage dictionary) for next compressed frame.
  /// A prefix is **only used once**. Tables are discarded at end of frame (ZSTD_e_end).
  /// Decompression will need same prefix to properly regenerate data.
  /// Compressing with a prefix is similar in outcome as performing a diff and compressing it,
  /// but performs much faster, especially during decompression (compression speed is tunable with compression level).
  /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
  /// Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary
  /// Note 1 : Prefix buffer is referenced. It **must** outlive compression.
  /// Its content must remain unmodified during compression.
  /// Note 2 : If the intention is to diff some large src data blob with some prior version of itself,
  /// ensure that the window size is large enough to contain the entire source.
  /// See ZSTD_c_windowLog.
  /// Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters.
  /// It's a CPU consuming operation, with non-negligible impact on latency.
  /// If there is a need to use the same prefix multiple times, consider loadDictionary instead.
  /// Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dct_rawContent).
  /// Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation.
  int ZSTD_CCtx_refPrefix(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
    ffi.Pointer<ffi.Void> prefix,
    int prefixSize,
  ) {
    _ZSTD_CCtx_refPrefix ??= _dylib.lookupFunction<_c_ZSTD_CCtx_refPrefix,
        _dart_ZSTD_CCtx_refPrefix>('ZSTD_CCtx_refPrefix');
    return _ZSTD_CCtx_refPrefix(
      cctx,
      prefix,
      prefixSize,
    );
  }

  _dart_ZSTD_CCtx_refPrefix _ZSTD_CCtx_refPrefix;

  /// ! ZSTD_DCtx_loadDictionary() :
  /// Create an internal DDict from dict buffer,
  /// to be used to decompress next frames.
  /// The dictionary remains valid for all future frames, until explicitly invalidated.
  /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
  /// Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary,
  /// meaning "return to no-dictionary mode".
  /// Note 1 : Loading a dictionary involves building tables,
  /// which has a non-negligible impact on CPU usage and latency.
  /// It's recommended to "load once, use many times", to amortize the cost
  /// Note 2 :`dict` content will be copied internally, so `dict` can be released after loading.
  /// Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead.
  /// Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of
  /// how dictionary content is loaded and interpreted.
  int ZSTD_DCtx_loadDictionary(
    ffi.Pointer<ZSTD_DCtx_s> dctx,
    ffi.Pointer<ffi.Void> dict,
    int dictSize,
  ) {
    _ZSTD_DCtx_loadDictionary ??= _dylib.lookupFunction<
        _c_ZSTD_DCtx_loadDictionary,
        _dart_ZSTD_DCtx_loadDictionary>('ZSTD_DCtx_loadDictionary');
    return _ZSTD_DCtx_loadDictionary(
      dctx,
      dict,
      dictSize,
    );
  }

  _dart_ZSTD_DCtx_loadDictionary _ZSTD_DCtx_loadDictionary;

  /// ! ZSTD_DCtx_refDDict() :
  /// Reference a prepared dictionary, to be used to decompress next frames.
  /// The dictionary remains active for decompression of future frames using same DCtx.
  /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
  /// Note 1 : Currently, only one dictionary can be managed.
  /// Referencing a new dictionary effectively "discards" any previous one.
  /// Special: referencing a NULL DDict means "return to no-dictionary mode".
  /// Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx.
  int ZSTD_DCtx_refDDict(
    ffi.Pointer<ZSTD_DCtx_s> dctx,
    ffi.Pointer<ZSTD_DDict_s> ddict,
  ) {
    _ZSTD_DCtx_refDDict ??=
        _dylib.lookupFunction<_c_ZSTD_DCtx_refDDict, _dart_ZSTD_DCtx_refDDict>(
            'ZSTD_DCtx_refDDict');
    return _ZSTD_DCtx_refDDict(
      dctx,
      ddict,
    );
  }

  _dart_ZSTD_DCtx_refDDict _ZSTD_DCtx_refDDict;

  /// ! ZSTD_DCtx_refPrefix() :
  /// Reference a prefix (single-usage dictionary) to decompress next frame.
  /// This is the reverse operation of ZSTD_CCtx_refPrefix(),
  /// and must use the same prefix as the one used during compression.
  /// Prefix is **only used once**. Reference is discarded at end of frame.
  /// End of frame is reached when ZSTD_decompressStream() returns 0.
  /// @result : 0, or an error code (which can be tested with ZSTD_isError()).
  /// Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary
  /// Note 2 : Prefix buffer is referenced. It **must** outlive decompression.
  /// Prefix buffer must remain unmodified up to the end of frame,
  /// reached when ZSTD_decompressStream() returns 0.
  /// Note 3 : By default, the prefix is treated as raw content (ZSTD_dct_rawContent).
  /// Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section)
  /// Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost.
  /// A full dictionary is more costly, as it requires building tables.
  int ZSTD_DCtx_refPrefix(
    ffi.Pointer<ZSTD_DCtx_s> dctx,
    ffi.Pointer<ffi.Void> prefix,
    int prefixSize,
  ) {
    _ZSTD_DCtx_refPrefix ??= _dylib.lookupFunction<_c_ZSTD_DCtx_refPrefix,
        _dart_ZSTD_DCtx_refPrefix>('ZSTD_DCtx_refPrefix');
    return _ZSTD_DCtx_refPrefix(
      dctx,
      prefix,
      prefixSize,
    );
  }

  _dart_ZSTD_DCtx_refPrefix _ZSTD_DCtx_refPrefix;

  /// ! ZSTD_sizeof_*() :
  /// These functions give the _current_ memory usage of selected object.
  /// Note that object memory usage can evolve (increase or decrease) over time.
  int ZSTD_sizeof_CCtx(
    ffi.Pointer<ZSTD_CCtx_s> cctx,
  ) {
    _ZSTD_sizeof_CCtx ??=
        _dylib.lookupFunction<_c_ZSTD_sizeof_CCtx, _dart_ZSTD_sizeof_CCtx>(
            'ZSTD_sizeof_CCtx');
    return _ZSTD_sizeof_CCtx(
      cctx,
    );
  }

  _dart_ZSTD_sizeof_CCtx _ZSTD_sizeof_CCtx;

  int ZSTD_sizeof_DCtx(
    ffi.Pointer<ZSTD_DCtx_s> dctx,
  ) {
    _ZSTD_sizeof_DCtx ??=
        _dylib.lookupFunction<_c_ZSTD_sizeof_DCtx, _dart_ZSTD_sizeof_DCtx>(
            'ZSTD_sizeof_DCtx');
    return _ZSTD_sizeof_DCtx(
      dctx,
    );
  }

  _dart_ZSTD_sizeof_DCtx _ZSTD_sizeof_DCtx;

  int ZSTD_sizeof_CStream(
    ffi.Pointer<ZSTD_CCtx_s> zcs,
  ) {
    _ZSTD_sizeof_CStream ??= _dylib.lookupFunction<_c_ZSTD_sizeof_CStream,
        _dart_ZSTD_sizeof_CStream>('ZSTD_sizeof_CStream');
    return _ZSTD_sizeof_CStream(
      zcs,
    );
  }

  _dart_ZSTD_sizeof_CStream _ZSTD_sizeof_CStream;

  int ZSTD_sizeof_DStream(
    ffi.Pointer<ZSTD_DCtx_s> zds,
  ) {
    _ZSTD_sizeof_DStream ??= _dylib.lookupFunction<_c_ZSTD_sizeof_DStream,
        _dart_ZSTD_sizeof_DStream>('ZSTD_sizeof_DStream');
    return _ZSTD_sizeof_DStream(
      zds,
    );
  }

  _dart_ZSTD_sizeof_DStream _ZSTD_sizeof_DStream;

  int ZSTD_sizeof_CDict(
    ffi.Pointer<ZSTD_CDict_s> cdict,
  ) {
    _ZSTD_sizeof_CDict ??=
        _dylib.lookupFunction<_c_ZSTD_sizeof_CDict, _dart_ZSTD_sizeof_CDict>(
            'ZSTD_sizeof_CDict');
    return _ZSTD_sizeof_CDict(
      cdict,
    );
  }

  _dart_ZSTD_sizeof_CDict _ZSTD_sizeof_CDict;

  int ZSTD_sizeof_DDict(
    ffi.Pointer<ZSTD_DDict_s> ddict,
  ) {
    _ZSTD_sizeof_DDict ??=
        _dylib.lookupFunction<_c_ZSTD_sizeof_DDict, _dart_ZSTD_sizeof_DDict>(
            'ZSTD_sizeof_DDict');
    return _ZSTD_sizeof_DDict(
      ddict,
    );
  }

  _dart_ZSTD_sizeof_DDict _ZSTD_sizeof_DDict;
}

class __darwin_pthread_handler_rec extends ffi.Struct {
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> __routine;

  ffi.Pointer<ffi.Void> __arg;

  ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

class _opaque_pthread_attr_t extends ffi.Struct {}

class _opaque_pthread_cond_t extends ffi.Struct {}

class _opaque_pthread_condattr_t extends ffi.Struct {}

class _opaque_pthread_mutex_t extends ffi.Struct {}

class _opaque_pthread_mutexattr_t extends ffi.Struct {}

class _opaque_pthread_once_t extends ffi.Struct {}

class _opaque_pthread_rwlock_t extends ffi.Struct {}

class _opaque_pthread_rwlockattr_t extends ffi.Struct {}

class _opaque_pthread_t extends ffi.Struct {}

class ZSTD_CCtx_s extends ffi.Struct {}

class ZSTD_DCtx_s extends ffi.Struct {}

/// Advanced compression API
abstract class ZSTD_strategy {
  static const int ZSTD_fast = 1;
  static const int ZSTD_dfast = 2;
  static const int ZSTD_greedy = 3;
  static const int ZSTD_lazy = 4;
  static const int ZSTD_lazy2 = 5;
  static const int ZSTD_btlazy2 = 6;
  static const int ZSTD_btopt = 7;
  static const int ZSTD_btultra = 8;
  static const int ZSTD_btultra2 = 9;
}

abstract class ZSTD_cParameter {
  static const int ZSTD_c_compressionLevel = 100;
  static const int ZSTD_c_windowLog = 101;
  static const int ZSTD_c_hashLog = 102;
  static const int ZSTD_c_chainLog = 103;
  static const int ZSTD_c_searchLog = 104;
  static const int ZSTD_c_minMatch = 105;
  static const int ZSTD_c_targetLength = 106;
  static const int ZSTD_c_strategy = 107;
  static const int ZSTD_c_enableLongDistanceMatching = 160;
  static const int ZSTD_c_ldmHashLog = 161;
  static const int ZSTD_c_ldmMinMatch = 162;
  static const int ZSTD_c_ldmBucketSizeLog = 163;
  static const int ZSTD_c_ldmHashRateLog = 164;
  static const int ZSTD_c_contentSizeFlag = 200;
  static const int ZSTD_c_checksumFlag = 201;
  static const int ZSTD_c_dictIDFlag = 202;
  static const int ZSTD_c_nbWorkers = 400;
  static const int ZSTD_c_jobSize = 401;
  static const int ZSTD_c_overlapLog = 402;
  static const int ZSTD_c_experimentalParam1 = 500;
  static const int ZSTD_c_experimentalParam2 = 10;
  static const int ZSTD_c_experimentalParam3 = 1000;
  static const int ZSTD_c_experimentalParam4 = 1001;
  static const int ZSTD_c_experimentalParam5 = 1002;
  static const int ZSTD_c_experimentalParam6 = 1003;
  static const int ZSTD_c_experimentalParam7 = 1004;
  static const int ZSTD_c_experimentalParam8 = 1005;
  static const int ZSTD_c_experimentalParam9 = 1006;
  static const int ZSTD_c_experimentalParam10 = 1007;
}

class ZSTD_bounds extends ffi.Struct {
  @ffi.Uint64()
  int error;

  @ffi.Int32()
  int lowerBound;

  @ffi.Int32()
  int upperBound;
}

abstract class ZSTD_ResetDirective {
  static const int ZSTD_reset_session_only = 1;
  static const int ZSTD_reset_parameters = 2;
  static const int ZSTD_reset_session_and_parameters = 3;
}

/// Advanced decompression API
abstract class ZSTD_dParameter {
  static const int ZSTD_d_windowLogMax = 100;
  static const int ZSTD_d_experimentalParam1 = 1000;
  static const int ZSTD_d_experimentalParam2 = 1001;
  static const int ZSTD_d_experimentalParam3 = 1002;
}

/// Streaming
class ZSTD_inBuffer extends ffi.Struct {
  /// < start of input buffer
  ffi.Pointer<ffi.Void> src;

  /// < size of input buffer
  @ffi.Uint64()
  int size;

  /// < position where reading stopped. Will be updated. Necessarily 0 <= pos <= size
  @ffi.Uint64()
  int pos;
}

class ZSTD_outBuffer extends ffi.Struct {
  /// < start of output buffer
  ffi.Pointer<ffi.Void> dst;

  /// < size of output buffer
  @ffi.Uint64()
  int size;

  /// < position where writing stopped. Will be updated. Necessarily 0 <= pos <= size
  @ffi.Uint64()
  int pos;
}

abstract class ZSTD_EndDirective {
  static const int ZSTD_e_continue = 0;
  static const int ZSTD_e_flush = 1;
  static const int ZSTD_e_end = 2;
}

class ZSTD_CDict_s extends ffi.Struct {}

class ZSTD_DDict_s extends ffi.Struct {}

const int __DARWIN_ONLY_64_BIT_INO_T = 0;

const int __DARWIN_ONLY_VERS_1050 = 0;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_64_BIT_INO_T = '\$INODE64';

const String __DARWIN_SUF_1050 = '\$1050';

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __DARWIN_CLK_TCK = 100;

const int CHAR_BIT = 8;

const int MB_LEN_MAX = 6;

const int CLK_TCK = 100;

const int SCHAR_MAX = 127;

const int SCHAR_MIN = -128;

const int UCHAR_MAX = 255;

const int CHAR_MAX = 127;

const int CHAR_MIN = -128;

const int USHRT_MAX = 65535;

const int SHRT_MAX = 32767;

const int SHRT_MIN = -32768;

const int UINT_MAX = 4294967295;

const int INT_MAX = 2147483647;

const int INT_MIN = -2147483648;

const int ULONG_MAX = -1;

const int LONG_MAX = 9223372036854775807;

const int LONG_MIN = -9223372036854775808;

const int ULLONG_MAX = -1;

const int LLONG_MAX = 9223372036854775807;

const int LLONG_MIN = -9223372036854775808;

const int LONG_BIT = 64;

const int SSIZE_MAX = 9223372036854775807;

const int WORD_BIT = 32;

const int SIZE_T_MAX = -1;

const int UQUAD_MAX = -1;

const int QUAD_MAX = 9223372036854775807;

const int QUAD_MIN = -9223372036854775808;

const int ARG_MAX = 262144;

const int CHILD_MAX = 266;

const int GID_MAX = 2147483647;

const int LINK_MAX = 32767;

const int MAX_CANON = 1024;

const int MAX_INPUT = 1024;

const int NAME_MAX = 255;

const int NGROUPS_MAX = 16;

const int UID_MAX = 2147483647;

const int OPEN_MAX = 10240;

const int PATH_MAX = 1024;

const int PIPE_BUF = 512;

const int BC_BASE_MAX = 99;

const int BC_DIM_MAX = 2048;

const int BC_SCALE_MAX = 99;

const int BC_STRING_MAX = 1000;

const int CHARCLASS_NAME_MAX = 14;

const int COLL_WEIGHTS_MAX = 2;

const int EQUIV_CLASS_MAX = 2;

const int EXPR_NEST_MAX = 32;

const int LINE_MAX = 2048;

const int RE_DUP_MAX = 255;

const int NZERO = 20;

const int _POSIX_ARG_MAX = 4096;

const int _POSIX_CHILD_MAX = 25;

const int _POSIX_LINK_MAX = 8;

const int _POSIX_MAX_CANON = 255;

const int _POSIX_MAX_INPUT = 255;

const int _POSIX_NAME_MAX = 14;

const int _POSIX_NGROUPS_MAX = 8;

const int _POSIX_OPEN_MAX = 20;

const int _POSIX_PATH_MAX = 256;

const int _POSIX_PIPE_BUF = 512;

const int _POSIX_SSIZE_MAX = 32767;

const int _POSIX_STREAM_MAX = 8;

const int _POSIX_TZNAME_MAX = 6;

const int _POSIX2_BC_BASE_MAX = 99;

const int _POSIX2_BC_DIM_MAX = 2048;

const int _POSIX2_BC_SCALE_MAX = 99;

const int _POSIX2_BC_STRING_MAX = 1000;

const int _POSIX2_EQUIV_CLASS_MAX = 2;

const int _POSIX2_EXPR_NEST_MAX = 32;

const int _POSIX2_LINE_MAX = 2048;

const int _POSIX2_RE_DUP_MAX = 255;

const int _POSIX_AIO_LISTIO_MAX = 2;

const int _POSIX_AIO_MAX = 1;

const int _POSIX_DELAYTIMER_MAX = 32;

const int _POSIX_MQ_OPEN_MAX = 8;

const int _POSIX_MQ_PRIO_MAX = 32;

const int _POSIX_RTSIG_MAX = 8;

const int _POSIX_SEM_NSEMS_MAX = 256;

const int _POSIX_SEM_VALUE_MAX = 32767;

const int _POSIX_SIGQUEUE_MAX = 32;

const int _POSIX_TIMER_MAX = 32;

const int _POSIX_CLOCKRES_MIN = 20000000;

const int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int _POSIX_THREAD_THREADS_MAX = 64;

const int PTHREAD_DESTRUCTOR_ITERATIONS = 4;

const int PTHREAD_KEYS_MAX = 512;

const int PTHREAD_STACK_MIN = 8192;

const int _POSIX_HOST_NAME_MAX = 255;

const int _POSIX_LOGIN_NAME_MAX = 9;

const int _POSIX_SS_REPL_MAX = 4;

const int _POSIX_SYMLINK_MAX = 255;

const int _POSIX_SYMLOOP_MAX = 8;

const int _POSIX_TRACE_EVENT_NAME_MAX = 30;

const int _POSIX_TRACE_NAME_MAX = 8;

const int _POSIX_TRACE_SYS_MAX = 8;

const int _POSIX_TRACE_USER_EVENT_MAX = 32;

const int _POSIX_TTY_NAME_MAX = 9;

const int _POSIX2_CHARCLASS_NAME_MAX = 14;

const int _POSIX2_COLL_WEIGHTS_MAX = 2;

const int _POSIX_RE_DUP_MAX = 255;

const int OFF_MIN = -9223372036854775808;

const int OFF_MAX = 9223372036854775807;

const int PASS_MAX = 128;

const int NL_ARGMAX = 9;

const int NL_LANGMAX = 14;

const int NL_MSGMAX = 32767;

const int NL_NMAX = 1;

const int NL_SETMAX = 255;

const int NL_TEXTMAX = 2048;

const int _XOPEN_IOV_MAX = 16;

const int IOV_MAX = 1024;

const int _XOPEN_NAME_MAX = 255;

const int _XOPEN_PATH_MAX = 1024;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int USER_ADDR_NULL = 0;

const int ZSTD_VERSION_MAJOR = 1;

const int ZSTD_VERSION_MINOR = 4;

const int ZSTD_VERSION_RELEASE = 6;

const int ZSTD_VERSION_NUMBER = 10406;

const String ZSTD_VERSION_STRING = '1.4.6';

const int ZSTD_CLEVEL_DEFAULT = 3;

const int ZSTD_MAGICNUMBER = 4247762216;

const int ZSTD_MAGIC_DICTIONARY = 3962610743;

const int ZSTD_MAGIC_SKIPPABLE_START = 407710288;

const int ZSTD_MAGIC_SKIPPABLE_MASK = 4294967280;

const int ZSTD_BLOCKSIZELOG_MAX = 17;

const int ZSTD_BLOCKSIZE_MAX = 131072;

const int ZSTD_CONTENTSIZE_UNKNOWN = -1;

const int ZSTD_CONTENTSIZE_ERROR = -2;

typedef _c_ZSTD_versionNumber = ffi.Uint32 Function();

typedef _dart_ZSTD_versionNumber = int Function();

typedef _c_ZSTD_versionString = ffi.Pointer<ffi.Int8> Function();

typedef _dart_ZSTD_versionString = ffi.Pointer<ffi.Int8> Function();

typedef _c_ZSTD_compress = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 dstCapacity,
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
  ffi.Int32 compressionLevel,
);

typedef _dart_ZSTD_compress = int Function(
  ffi.Pointer<ffi.Void> dst,
  int dstCapacity,
  ffi.Pointer<ffi.Void> src,
  int srcSize,
  int compressionLevel,
);

typedef _c_ZSTD_decompress = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 dstCapacity,
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 compressedSize,
);

typedef _dart_ZSTD_decompress = int Function(
  ffi.Pointer<ffi.Void> dst,
  int dstCapacity,
  ffi.Pointer<ffi.Void> src,
  int compressedSize,
);

typedef _c_ZSTD_getFrameContentSize = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
);

typedef _dart_ZSTD_getFrameContentSize = int Function(
  ffi.Pointer<ffi.Void> src,
  int srcSize,
);

typedef _c_ZSTD_getDecompressedSize = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
);

typedef _dart_ZSTD_getDecompressedSize = int Function(
  ffi.Pointer<ffi.Void> src,
  int srcSize,
);

typedef _c_ZSTD_findFrameCompressedSize = ffi.Uint64 Function(
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
);

typedef _dart_ZSTD_findFrameCompressedSize = int Function(
  ffi.Pointer<ffi.Void> src,
  int srcSize,
);

typedef _c_ZSTD_compressBound = ffi.Uint64 Function(
  ffi.Uint64 srcSize,
);

typedef _dart_ZSTD_compressBound = int Function(
  int srcSize,
);

typedef _c_ZSTD_isError = ffi.Uint32 Function(
  ffi.Uint64 code,
);

typedef _dart_ZSTD_isError = int Function(
  int code,
);

typedef _c_ZSTD_getErrorName = ffi.Pointer<ffi.Int8> Function(
  ffi.Uint64 code,
);

typedef _dart_ZSTD_getErrorName = ffi.Pointer<ffi.Int8> Function(
  int code,
);

typedef _c_ZSTD_minCLevel = ffi.Int32 Function();

typedef _dart_ZSTD_minCLevel = int Function();

typedef _c_ZSTD_maxCLevel = ffi.Int32 Function();

typedef _dart_ZSTD_maxCLevel = int Function();

typedef _c_ZSTD_createCCtx = ffi.Pointer<ZSTD_CCtx_s> Function();

typedef _dart_ZSTD_createCCtx = ffi.Pointer<ZSTD_CCtx_s> Function();

typedef _c_ZSTD_freeCCtx = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
);

typedef _dart_ZSTD_freeCCtx = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
);

typedef _c_ZSTD_compressCCtx = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 dstCapacity,
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
  ffi.Int32 compressionLevel,
);

typedef _dart_ZSTD_compressCCtx = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ffi.Void> dst,
  int dstCapacity,
  ffi.Pointer<ffi.Void> src,
  int srcSize,
  int compressionLevel,
);

typedef _c_ZSTD_createDCtx = ffi.Pointer<ZSTD_DCtx_s> Function();

typedef _dart_ZSTD_createDCtx = ffi.Pointer<ZSTD_DCtx_s> Function();

typedef _c_ZSTD_freeDCtx = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
);

typedef _dart_ZSTD_freeDCtx = int Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
);

typedef _c_ZSTD_decompressDCtx = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 dstCapacity,
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
);

typedef _dart_ZSTD_decompressDCtx = int Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ffi.Void> dst,
  int dstCapacity,
  ffi.Pointer<ffi.Void> src,
  int srcSize,
);

typedef _c_ZSTD_CCtx_setParameter = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Int32 param,
  ffi.Int32 value,
);

typedef _dart_ZSTD_CCtx_setParameter = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  int param,
  int value,
);

typedef _c_ZSTD_CCtx_setPledgedSrcSize = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Uint64 pledgedSrcSize,
);

typedef _dart_ZSTD_CCtx_setPledgedSrcSize = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  int pledgedSrcSize,
);

typedef _c_ZSTD_CCtx_reset = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Int32 reset,
);

typedef _dart_ZSTD_CCtx_reset = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  int reset,
);

typedef _c_ZSTD_compress2 = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 dstCapacity,
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
);

typedef _dart_ZSTD_compress2 = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ffi.Void> dst,
  int dstCapacity,
  ffi.Pointer<ffi.Void> src,
  int srcSize,
);

typedef _c_ZSTD_DCtx_setParameter = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Int32 param,
  ffi.Int32 value,
);

typedef _dart_ZSTD_DCtx_setParameter = int Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  int param,
  int value,
);

typedef _c_ZSTD_DCtx_reset = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Int32 reset,
);

typedef _dart_ZSTD_DCtx_reset = int Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  int reset,
);

typedef _c_ZSTD_createCStream = ffi.Pointer<ZSTD_CCtx_s> Function();

typedef _dart_ZSTD_createCStream = ffi.Pointer<ZSTD_CCtx_s> Function();

typedef _c_ZSTD_freeCStream = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
);

typedef _dart_ZSTD_freeCStream = int Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
);

typedef _c_ZSTD_compressStream2 = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ZSTD_outBuffer> output,
  ffi.Pointer<ZSTD_inBuffer> input,
  ffi.Int32 endOp,
);

typedef _dart_ZSTD_compressStream2 = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ZSTD_outBuffer> output,
  ffi.Pointer<ZSTD_inBuffer> input,
  int endOp,
);

typedef _c_ZSTD_CStreamInSize = ffi.Uint64 Function();

typedef _dart_ZSTD_CStreamInSize = int Function();

typedef _c_ZSTD_CStreamOutSize = ffi.Uint64 Function();

typedef _dart_ZSTD_CStreamOutSize = int Function();

typedef _c_ZSTD_initCStream = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
  ffi.Int32 compressionLevel,
);

typedef _dart_ZSTD_initCStream = int Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
  int compressionLevel,
);

typedef _c_ZSTD_compressStream = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
  ffi.Pointer<ZSTD_outBuffer> output,
  ffi.Pointer<ZSTD_inBuffer> input,
);

typedef _dart_ZSTD_compressStream = int Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
  ffi.Pointer<ZSTD_outBuffer> output,
  ffi.Pointer<ZSTD_inBuffer> input,
);

typedef _c_ZSTD_flushStream = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
  ffi.Pointer<ZSTD_outBuffer> output,
);

typedef _dart_ZSTD_flushStream = int Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
  ffi.Pointer<ZSTD_outBuffer> output,
);

typedef _c_ZSTD_endStream = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
  ffi.Pointer<ZSTD_outBuffer> output,
);

typedef _dart_ZSTD_endStream = int Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
  ffi.Pointer<ZSTD_outBuffer> output,
);

typedef _c_ZSTD_createDStream = ffi.Pointer<ZSTD_DCtx_s> Function();

typedef _dart_ZSTD_createDStream = ffi.Pointer<ZSTD_DCtx_s> Function();

typedef _c_ZSTD_freeDStream = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> zds,
);

typedef _dart_ZSTD_freeDStream = int Function(
  ffi.Pointer<ZSTD_DCtx_s> zds,
);

typedef _c_ZSTD_initDStream = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> zds,
);

typedef _dart_ZSTD_initDStream = int Function(
  ffi.Pointer<ZSTD_DCtx_s> zds,
);

typedef _c_ZSTD_decompressStream = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> zds,
  ffi.Pointer<ZSTD_outBuffer> output,
  ffi.Pointer<ZSTD_inBuffer> input,
);

typedef _dart_ZSTD_decompressStream = int Function(
  ffi.Pointer<ZSTD_DCtx_s> zds,
  ffi.Pointer<ZSTD_outBuffer> output,
  ffi.Pointer<ZSTD_inBuffer> input,
);

typedef _c_ZSTD_DStreamInSize = ffi.Uint64 Function();

typedef _dart_ZSTD_DStreamInSize = int Function();

typedef _c_ZSTD_DStreamOutSize = ffi.Uint64 Function();

typedef _dart_ZSTD_DStreamOutSize = int Function();

typedef _c_ZSTD_compress_usingDict = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> ctx,
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 dstCapacity,
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
  ffi.Pointer<ffi.Void> dict,
  ffi.Uint64 dictSize,
  ffi.Int32 compressionLevel,
);

typedef _dart_ZSTD_compress_usingDict = int Function(
  ffi.Pointer<ZSTD_CCtx_s> ctx,
  ffi.Pointer<ffi.Void> dst,
  int dstCapacity,
  ffi.Pointer<ffi.Void> src,
  int srcSize,
  ffi.Pointer<ffi.Void> dict,
  int dictSize,
  int compressionLevel,
);

typedef _c_ZSTD_decompress_usingDict = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 dstCapacity,
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
  ffi.Pointer<ffi.Void> dict,
  ffi.Uint64 dictSize,
);

typedef _dart_ZSTD_decompress_usingDict = int Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ffi.Void> dst,
  int dstCapacity,
  ffi.Pointer<ffi.Void> src,
  int srcSize,
  ffi.Pointer<ffi.Void> dict,
  int dictSize,
);

typedef _c_ZSTD_createCDict = ffi.Pointer<ZSTD_CDict_s> Function(
  ffi.Pointer<ffi.Void> dictBuffer,
  ffi.Uint64 dictSize,
  ffi.Int32 compressionLevel,
);

typedef _dart_ZSTD_createCDict = ffi.Pointer<ZSTD_CDict_s> Function(
  ffi.Pointer<ffi.Void> dictBuffer,
  int dictSize,
  int compressionLevel,
);

typedef _c_ZSTD_freeCDict = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CDict_s> CDict,
);

typedef _dart_ZSTD_freeCDict = int Function(
  ffi.Pointer<ZSTD_CDict_s> CDict,
);

typedef _c_ZSTD_compress_usingCDict = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 dstCapacity,
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
  ffi.Pointer<ZSTD_CDict_s> cdict,
);

typedef _dart_ZSTD_compress_usingCDict = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ffi.Void> dst,
  int dstCapacity,
  ffi.Pointer<ffi.Void> src,
  int srcSize,
  ffi.Pointer<ZSTD_CDict_s> cdict,
);

typedef _c_ZSTD_createDDict = ffi.Pointer<ZSTD_DDict_s> Function(
  ffi.Pointer<ffi.Void> dictBuffer,
  ffi.Uint64 dictSize,
);

typedef _dart_ZSTD_createDDict = ffi.Pointer<ZSTD_DDict_s> Function(
  ffi.Pointer<ffi.Void> dictBuffer,
  int dictSize,
);

typedef _c_ZSTD_freeDDict = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DDict_s> ddict,
);

typedef _dart_ZSTD_freeDDict = int Function(
  ffi.Pointer<ZSTD_DDict_s> ddict,
);

typedef _c_ZSTD_decompress_usingDDict = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ffi.Void> dst,
  ffi.Uint64 dstCapacity,
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
  ffi.Pointer<ZSTD_DDict_s> ddict,
);

typedef _dart_ZSTD_decompress_usingDDict = int Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ffi.Void> dst,
  int dstCapacity,
  ffi.Pointer<ffi.Void> src,
  int srcSize,
  ffi.Pointer<ZSTD_DDict_s> ddict,
);

typedef _c_ZSTD_getDictID_fromDict = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> dict,
  ffi.Uint64 dictSize,
);

typedef _dart_ZSTD_getDictID_fromDict = int Function(
  ffi.Pointer<ffi.Void> dict,
  int dictSize,
);

typedef _c_ZSTD_getDictID_fromDDict = ffi.Uint32 Function(
  ffi.Pointer<ZSTD_DDict_s> ddict,
);

typedef _dart_ZSTD_getDictID_fromDDict = int Function(
  ffi.Pointer<ZSTD_DDict_s> ddict,
);

typedef _c_ZSTD_getDictID_fromFrame = ffi.Uint32 Function(
  ffi.Pointer<ffi.Void> src,
  ffi.Uint64 srcSize,
);

typedef _dart_ZSTD_getDictID_fromFrame = int Function(
  ffi.Pointer<ffi.Void> src,
  int srcSize,
);

typedef _c_ZSTD_CCtx_loadDictionary = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ffi.Void> dict,
  ffi.Uint64 dictSize,
);

typedef _dart_ZSTD_CCtx_loadDictionary = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ffi.Void> dict,
  int dictSize,
);

typedef _c_ZSTD_CCtx_refCDict = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ZSTD_CDict_s> cdict,
);

typedef _dart_ZSTD_CCtx_refCDict = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ZSTD_CDict_s> cdict,
);

typedef _c_ZSTD_CCtx_refPrefix = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ffi.Void> prefix,
  ffi.Uint64 prefixSize,
);

typedef _dart_ZSTD_CCtx_refPrefix = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
  ffi.Pointer<ffi.Void> prefix,
  int prefixSize,
);

typedef _c_ZSTD_DCtx_loadDictionary = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ffi.Void> dict,
  ffi.Uint64 dictSize,
);

typedef _dart_ZSTD_DCtx_loadDictionary = int Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ffi.Void> dict,
  int dictSize,
);

typedef _c_ZSTD_DCtx_refDDict = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ZSTD_DDict_s> ddict,
);

typedef _dart_ZSTD_DCtx_refDDict = int Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ZSTD_DDict_s> ddict,
);

typedef _c_ZSTD_DCtx_refPrefix = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ffi.Void> prefix,
  ffi.Uint64 prefixSize,
);

typedef _dart_ZSTD_DCtx_refPrefix = int Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
  ffi.Pointer<ffi.Void> prefix,
  int prefixSize,
);

typedef _c_ZSTD_sizeof_CCtx = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
);

typedef _dart_ZSTD_sizeof_CCtx = int Function(
  ffi.Pointer<ZSTD_CCtx_s> cctx,
);

typedef _c_ZSTD_sizeof_DCtx = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
);

typedef _dart_ZSTD_sizeof_DCtx = int Function(
  ffi.Pointer<ZSTD_DCtx_s> dctx,
);

typedef _c_ZSTD_sizeof_CStream = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
);

typedef _dart_ZSTD_sizeof_CStream = int Function(
  ffi.Pointer<ZSTD_CCtx_s> zcs,
);

typedef _c_ZSTD_sizeof_DStream = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DCtx_s> zds,
);

typedef _dart_ZSTD_sizeof_DStream = int Function(
  ffi.Pointer<ZSTD_DCtx_s> zds,
);

typedef _c_ZSTD_sizeof_CDict = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_CDict_s> cdict,
);

typedef _dart_ZSTD_sizeof_CDict = int Function(
  ffi.Pointer<ZSTD_CDict_s> cdict,
);

typedef _c_ZSTD_sizeof_DDict = ffi.Uint64 Function(
  ffi.Pointer<ZSTD_DDict_s> ddict,
);

typedef _dart_ZSTD_sizeof_DDict = int Function(
  ffi.Pointer<ZSTD_DDict_s> ddict,
);

typedef _typedefC_1 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
);
